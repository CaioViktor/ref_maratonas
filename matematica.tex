\section{Matemática}

% % % % % % % % % % % % %
% % TEORIA DOS NÚMEROS 
% % % % % % % % % % % % %
\subsection{Teoria dos Números e Matemática Discreta}

\subsubsection{MMC}
O MMC de dois n\'{u}meros pode ser calculado da seguinte forma:
\\ Se:
  \[
  \left \{
  \begin{tabular}{c}
    $X=p1^{e11}*p2^{e12}*...*pn^{e1n}$ \\
    $Y=p1^{e21}*p2^{e22}*...*pn^{e2n}$
   \end{tabular}
   \right.
   \]
\\ 
\\ \centerline{$MMC(X,Y)=p1^{max(e11,e21)}*p2^{max(e12,e22)}*...*pn^{max(e1n,e2n)}$}
\\
\\ Onde $px$ \'{e} um fator primo presente em qualquer um dos dois n\'{u}meros ($ekx$ pode ser zero, n\~{a}o afeta o resultado final). Isso \'{e} \'{u}til quando o MMC pode ser muito grande e se quer calcular MMC \% MOD.

\divisor

\subsubsection{Multiplicative/Modular Inverse}
Encontra X tal que a $\times$ x = $\frac{a}{b}$ (mod m), ou seja, x é o equivalente do inverso do módulo de b. Implementação usando Euclidean Algorithm.
\Cpp{\detokenize{matematica/teoria_dos_numeros/modular_inverse}}
\divisor

\subsubsection{Exponentiation by squaring}
Calcula $a^b$ (mod m) em tempo O($\log{b}$)
\Cpp{\detokenize{matematica/teoria_dos_numeros/modpow}}
\divisor

% % % % % % % % % % % % %
% % COMBINATORIA
% % % % % % % % % % % % %

\subsection{Combinat\'{o}ria}

\subsubsection{Principo da inclus\~{a}o-exclus\~{a}o}
Generaliza a contagem da uni\~{a}o de conjuntos finitos. Por exemplo, para tr\^{e}s conjuntos, tem-se:

$|A \cup B \cup C| = |A| + |B| + |C| - (|A \cap B| + |A \cap C| + |B \cap C|) + |A \cap B \cap C|$

Ou seja, a cada passo \'{e} corrigido o somat\'{o}rio, removendo ou adicionando as interse\c{c}\~{o}es. De forma gen\'{e}rica, tem-se:

$|A_1 \cup ... \cup A_n| = \sum_{k=1}^{n} ((-1)^{k+1}*(\sum_{1 \leq i_1 < ... < i_k \leq n} |A_{i1} \cap ... \cap A_{ik}|))$

Onde $k$ \'{e} a quantidade de itens na contagem da interse\c{c}\~{a}o.

\divisor

% % % % % % % % % % % % %
% % CÁLCULO
% % % % % % % % % % % % %

\subsection{Cálculo}

\subsubsection{Integral definida/Regra de Simpson}
Integra $f(x)$ de $a$ a $b$. Necessário implementar $f(x)$.
\Cpp{matematica/calculo/simpson}  
% Problema bom pra testar: UVA 12528 - Environment Protection (Nacional 2012)

\divisor


% % % % % % % % % % % % %
% % ALGEBRA LINEAR
% % % % % % % % % % % % %

\subsection{Álgebra Linear}

\subsubsection{Recorrências lineares por matriz}
Em uma recorrência linear, pode-se encontrar o n-ésimo elemento em $O(\log{n})$ usando exponenciação de matrizes. Por exemplo, na sequência de Fibonacci temos:
\\ $f(n) = f(n)$
\\ $f(n+1) = f(n)+f(n-1)$
\\Na forma matricial, temos:
\\
$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right)
 = 
\left( \begin{array}{c}
f(n) + f(n-1) \\
f(n) \end{array} \right)
 = T \times
\left( \begin{array}{c}
f(n) \\
f(n-1) \end{array} \right)$
\\ Onde T é a matriz de transformação da recorrência e pode-se notar que:
$T=\left( \begin{array}{cc}
1 & 1 \\
1 & 0 \end{array} \right)$
\\ Seguindo a recorrência e lembrando que $f(0) = f(1) = 1$, tem-se que:
\\$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right) = T^n \times
\left( \begin{array}{c}
1 \\
1 \end{array} \right)$
\\ No caso geral, se a matriz T for suficientemente pequena, pode-se calcular o n-ésimo item da recorrência ao se calcular $T^n$. A implementação em $O(\log{n})$ é obtida usando exponentiation by squaring, caso T seja suficientemente pequeno (multiplica\c{c}\~{a}o de matrizes: $O(n^3)$).
% Para treinar/testar: http://www.urionlinejudge.com.br/judge/problems/view/1422
% Mais detalhes: http://fusharblog.com/solving-linear-recurrence-for-programming-contest/

\divisor
\subsubsection{Gaussian Elimination}
Para resolu\c{c}\~{a}o de sistemas de equa\c{c}\~{o}es lineares. Para um sistema $A*x = B$, a matriz de input do algor\'{i}tmo \'{e} a matriz $A$ concatenada com $B$.

\Cpp{\detokenize{matematica/algebra_linear/gaussian_elimination}}
\divisor
