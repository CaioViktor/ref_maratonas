\section{Matemática}

% % % % % % % % % % % % %
% % TEORIA DOS NÚMEROS 
% % % % % % % % % % % % %
\subsection{Teoria dos Números e Matemática Discreta}

\subsubsection{MMC}
O MMC de dois n\'{u}meros pode ser calculado da seguinte forma:
\\ Se:
  \[
  \left \{
  \begin{tabular}{c}
    $X=p1^{e11}*p2^{e12}*...*pn^{e1n}$ \\
    $Y=p1^{e21}*p2^{e22}*...*pn^{e2n}$
   \end{tabular}
   \right.
   \]
\\ 
\\ \centerline{$MMC(X,Y)=p1^{max(e11,e21)}*p2^{max(e12,e22)}*...*pn^{max(e1n,e2n)}$}
\\
\\ Onde $px$ \'{e} um fator primo presente em qualquer um dos dois n\'{u}meros ($ekx$ pode ser zero, n\~{a}o afeta o resultado final). Isso \'{e} \'{u}til quando o MMC pode ser muito grande e se quer calcular MMC \% MOD.

\divisor

\subsubsection{Multiplicative/Modular Inverse}
Encontra X tal que a $\times$ x = $\frac{a}{b}$ (mod m), ou seja, x é o equivalente do inverso do módulo de b. Implementação usando Euclidean Algorithm.
\Cpp{\detokenize{matematica/teoria_dos_numeros/modular_inverse}}
\divisor

\subsubsection{Exponentiation by squaring}
Calcula $a^b$ (mod m) em tempo O($\log{b}$)
\Cpp{\detokenize{matematica/teoria_dos_numeros/modpow}}
\divisor

\subsubsection{Euler's Totient Function}
Encontra a quantidade de inteiros menores que $n$ relativamente primos a $n$.
\Cpp{\detokenize{matematica/teoria_dos_numeros/euler_phi}}
\divisor

\subsubsection{Euler's Totient Theorem}
Se $n$ \'{e} um inteiro positivo e $a$ \'{e} coprimo de $n$, ent\~{a}o
$a^{\Phi (n) } = 1 \bmod{p}$
\divisor

% % % % % % % % % % % % %
% % COMBINATORIA
% % % % % % % % % % % % %

\subsection{Combinat\'{o}ria}

\subsubsection{Princ\'{i}pio da inclus\~{a}o-exclus\~{a}o}
Generaliza a contagem da uni\~{a}o de conjuntos finitos. Por exemplo, para tr\^{e}s conjuntos, tem-se:

$|A \cup B \cup C| = |A| + |B| + |C| - (|A \cap B| + |A \cap C| + |B \cap C|) + |A \cap B \cap C|$

Ou seja, a cada passo \'{e} corrigido o somat\'{o}rio, removendo ou adicionando as interse\c{c}\~{o}es. De forma gen\'{e}rica, tem-se:

$|A_1 \cup ... \cup A_n| = \sum_{k=1}^{n} ((-1)^{k+1}*(\sum_{1 \leq i_1 < ... < i_k \leq n} |A_{i1} \cap ... \cap A_{ik}|))$

Onde $k$ \'{e} a quantidade de itens na contagem da interse\c{c}\~{a}o.

\divisor

\subsubsection{Stars and Bars}
\textbf{Teorema 1}: Para quaisquer $n$ e $k$ positivos e inteiros, o n\'{u}mero de listas ordenadas distintas com $k$ n\'{u}meros \textbf{inteiros positivos} e soma igual a $n$ \'{e} ${n-1 \choose k-1}$ \\

\textbf{Teorema 2}: Para quaisquer $n$ e $k$ naturais, o n\'{u}mero de listas ordenadas distintas com $k$ n\'{u}meros \textbf{inteiros n\~{a}o negativos} e soma igual a $n$ \'{e} ${n+k-1 \choose n}$

\divisor

\subsubsection{Teorema de Lucas}

${n \choose k} \bmod{p} = {\left \lfloor{n/p}\right \rfloor \choose \left \lfloor{k/p}\right \rfloor} * {n \bmod{p} \choose k \bmod{p}} \bmod{p}$

% http://www.cut-the-knot.org/arithmetic/algebra/LucasTheorem.shtml


% % % % % % % % % % % % %
% % CÁLCULO
% % % % % % % % % % % % %

\subsection{Cálculo}

\subsubsection{Integral definida/Regra de Simpson}
Integra $f(x)$ de $a$ a $b$. Necessário implementar $f(x)$.
\Cpp{matematica/calculo/simpson}  
% Problema bom pra testar: UVA 12528 - Environment Protection (Nacional 2012)

\divisor

\subsubsection{FFT}
Faz multiplica\c{c}\~{a}o de polin\^{o}mios de grau $n$ em $O(n*log(n))$.\\
Para o algor\'{i}tmo funcionar, $n=2^k$. Se um polin\^{o}mio n\~{a}o tiver grau $2^k$, adicionar coeficientes nulos at\'{e} atingir a pr\'{o}xima pot\^{e}ncia de dois.\\
Lembrar que na multiplica\c{c}\~{a}o o polin\^{o}mio resultante ter\'{a} grau $2*n$, portanto adicionar zeros na frente dos polin\^{o}mios a serem multiplicados, deixando-os com grau $2^{k+1}$.
\Cpp{\detokenize{matematica/calculo/fft}}

% http://www.codechef.com/problems/FARASA
% mais info: http://habrahabr.ru/post/113642/
% mais recursos: http://www.ic.unicamp.br/~maratona/wiki/index.php?n=Numericos.FFT
\divisor

\subsubsection{Interpola\c{c}\~{a}o polinomial - Lagrange}
\Cpp{\detokenize{matematica/calculo/lagrange}}

% % % % % % % % % % % % %
% % ALGEBRA LINEAR
% % % % % % % % % % % % %

\subsection{Álgebra Linear}

\subsubsection{Recorrências lineares por matriz}
Em uma recorrência linear, pode-se encontrar o n-ésimo elemento em $O(\log{n})$ usando exponenciação de matrizes. Por exemplo, na sequência de Fibonacci temos:
\\ $f(n) = f(n)$
\\ $f(n+1) = f(n)+f(n-1)$
\\Na forma matricial, temos:
\\
$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right)
 = 
\left( \begin{array}{c}
f(n) + f(n-1) \\
f(n) \end{array} \right)
 = T \times
\left( \begin{array}{c}
f(n) \\
f(n-1) \end{array} \right)$
\\ Onde T é a matriz de transformação da recorrência e pode-se notar que:
$T=\left( \begin{array}{cc}
1 & 1 \\
1 & 0 \end{array} \right)$
\\ Seguindo a recorrência e lembrando que $f(0) = f(1) = 1$, tem-se que:
\\$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right) = T^n \times
\left( \begin{array}{c}
1 \\
1 \end{array} \right)$
\\ No caso geral, se a matriz T for suficientemente pequena, pode-se calcular o n-ésimo item da recorrência ao se calcular $T^n$. A implementação em $O(\log{n})$ é obtida usando exponentiation by squaring, caso T seja suficientemente pequeno (multiplica\c{c}\~{a}o de matrizes: $O(n^3)$).
% Para treinar/testar: http://www.urionlinejudge.com.br/judge/problems/view/1422
% Mais detalhes: http://fusharblog.com/solving-linear-recurrence-for-programming-contest/

\divisor
\subsubsection{Gaussian Elimination}
Para resolu\c{c}\~{a}o de sistemas de equa\c{c}\~{o}es lineares. Para um sistema $A*x = B$, a matriz de input do algor\'{i}tmo \'{e} a matriz $A$ concatenada com $B$.

\Cpp{\detokenize{matematica/algebra_linear/gaussian_elimination}}
\divisor
