\section{Matemática}

% % % % % % % % % % % % %
% % TEORIA DOS NÚMEROS 
% % % % % % % % % % % % %
\subsection{Teoria dos Números e Matemática Discreta}

\subsubsection{Propriedades GCD}
  \begin{itemize}
    \item Every common divisor of a and b is a divisor of gcd(a, b).
    \item $gcd(a, b)$, where $a$ and $b$ are not both zero, may be defined alternatively and equivalently as the smallest positive integer $d$ which can be written in the form $d = a*p + b*q$, where $p$ and $q$ are integers. This expression is called Bézout's identity. Numbers $p$ and $q$ like this can be computed with the extended Euclidean algorithm.
    \item $gcd(a, 0) = |a|$, for $a \neq 0$, since any number is a divisor of $0$, and the greatest divisor of $a$ is $|a|$. This is usually used as the base case in the Euclidean algorithm.
    \item If $a$ divides the product $b*c$, and $gcd(a, b) = d$, then $a/d$ divides $c$.
    \item If $m$ is a non-negative integer, then $gcd(m*a, m*b)$ = $m*gcd(a, b)$.
    \item If $m$ is any integer, then $gcd(a + m*b, b) = gcd(a, b)$.
    \item If $m$ is a nonzero common divisor of $a$ and $b$, then $gcd(a/m, b/m) = gcd(a, b)/m$.
    \item The gcd is a multiplicative function in the following sense: if $a_1$ and $a_2$ are relatively prime, then $gcd(a_1*a_2, b) = gcd(a1, b)*gcd(a2, b)$. In particular, recalling that gcd is a positive integer valued function (i.e, gets natural values only) we obtain that $gcd(a, b*c) = 1$ if and only if $gcd(a, b) = 1$ and $gcd(a, c) = 1$.
    \item The gcd is a commutative function: $gcd(a, b) = gcd(b, a)$.
    \item The gcd is an associative function: $gcd(a, gcd(b, c)) = gcd(gcd(a, b), c)$.
    \item The gcd of three numbers can be computed as $gcd(a, b, c) = gcd(gcd(a, b), c)$, or in some different way by applying commutativity and associativity. This can be extended to any number of numbers.
    \item $gcd(a, b)$ is closely related to the least common multiple $lcm(a, b)$: we have $gcd(a, b)*lcm(a, b) = a*b$. This formula is often used to compute least common multiples: one first computes the gcd with Euclid's algorithm and then divides the product of the given numbers by their gcd.
    \item The following versions of distributivity hold true:
    \begin{itemize}
      \item $gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c))$
      \item $lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c))$.
    \end{itemize}
    \item It is sometimes useful to define $gcd(0, 0) = 0$ and $lcm(0, 0) = 0$ because then the natural numbers become a complete distributive lattice with gcd as meet and lcm as join operation. This extension of the definition is also compatible with the generalization for commutative rings given below.
    \item In a Cartesian coordinate system, $gcd(a, b)$ can be interpreted as the number of points with integral coordinates on the straight line joining the points $(0, 0)$ and $(a, b)$, excluding $(0, 0)$.
  \end{itemize}
\divisor


\subsubsection{MMC}
O MMC de dois n\'{u}meros pode ser calculado da seguinte forma:
\\ Se:
  \[
  \left \{
  \begin{tabular}{c}
    $X=p1^{e11}*p2^{e12}*...*pn^{e1n}$ \\
    $Y=p1^{e21}*p2^{e22}*...*pn^{e2n}$
   \end{tabular}
   \right.
   \]
\\ 
\\ \centerline{$MMC(X,Y)=p1^{max(e11,e21)}*p2^{max(e12,e22)}*...*pn^{max(e1n,e2n)}$}
\\
\\ Onde $px$ \'{e} um fator primo presente em qualquer um dos dois n\'{u}meros ($ekx$ pode ser zero, n\~{a}o afeta o resultado final). Isso \'{e} \'{u}til quando o MMC pode ser muito grande e se quer calcular MMC \% MOD.

\divisor

\subsubsection{Multiplicative/Modular Inverse}
Encontra X tal que a $\times$ x = $\frac{a}{b}$ (mod m), ou seja, x é o equivalente do inverso do módulo de b. Implementação usando Euclidean Algorithm.
\Cpp{\detokenize{matematica/teoria_dos_numeros/modular_inverse}}
\divisor

\subsubsection{Exponentiation by squaring}
Calcula $a^b$ (mod m) em tempo O($\log{b}$)
\Cpp{\detokenize{matematica/teoria_dos_numeros/modpow}}
\divisor

\subsubsection{Euler's Totient Function}
Encontra a quantidade de inteiros menores que $n$ relativamente primos a $n$.
\Cpp{\detokenize{matematica/teoria_dos_numeros/euler_phi}}
\divisor

\subsubsection{Euler's Totient Theorem}
Se $n$ \'{e} um inteiro positivo e $a$ \'{e} coprimo de $n$, ent\~{a}o
$a^{\Phi (n) } = 1 \bmod{p}$
\divisor

\subsubsection{Chinese Remainder Theorem}
\Cpp{\detokenize{matematica/teoria_dos_numeros/crt}}
\divisor

% % % % % % % % % % % % %
% % COMBINATORIA
% % % % % % % % % % % % %

\subsection{Combinat\'{o}ria}

\subsubsection{Princ\'{i}pio da inclus\~{a}o-exclus\~{a}o}
Generaliza a contagem da uni\~{a}o de conjuntos finitos. Por exemplo, para tr\^{e}s conjuntos, tem-se:

$|A \cup B \cup C| = |A| + |B| + |C| - (|A \cap B| + |A \cap C| + |B \cap C|) + |A \cap B \cap C|$

Ou seja, a cada passo \'{e} corrigido o somat\'{o}rio, removendo ou adicionando as interse\c{c}\~{o}es. De forma gen\'{e}rica, tem-se:

$|A_1 \cup ... \cup A_n| = \sum_{k=1}^{n} ((-1)^{k+1}*(\sum_{1 \leq i_1 < ... < i_k \leq n} |A_{i1} \cap ... \cap A_{ik}|))$

Onde $k$ \'{e} a quantidade de itens na contagem da interse\c{c}\~{a}o.

\divisor

\subsubsection{Stars and Bars}
\textbf{Teorema 1}: Para quaisquer $n$ e $k$ positivos e inteiros, o n\'{u}mero de listas ordenadas distintas com $k$ n\'{u}meros \textbf{inteiros positivos} e soma igual a $n$ \'{e} ${n-1 \choose k-1}$ \\

\textbf{Teorema 2}: Para quaisquer $n$ e $k$ naturais, o n\'{u}mero de listas ordenadas distintas com $k$ n\'{u}meros \textbf{inteiros n\~{a}o negativos} e soma igual a $n$ \'{e} ${n+k-1 \choose n}$

\divisor

\subsubsection{Teorema de Lucas}

${n \choose k} \bmod{p} = {\left \lfloor{n/p}\right \rfloor \choose \left \lfloor{k/p}\right \rfloor} * {n \bmod{p} \choose k \bmod{p}} \bmod{p}$

% http://www.cut-the-knot.org/arithmetic/algebra/LucasTheorem.shtml


% % % % % % % % % % % % %
% % CÁLCULO
% % % % % % % % % % % % %

\subsection{Cálculo}

\subsubsection{Integral definida/Regra de Simpson}
Integra $f(x)$ de $a$ a $b$. Necessário implementar $f(x)$.
\Cpp{matematica/calculo/simpson}  
% Problema bom pra testar: UVA 12528 - Environment Protection (Nacional 2012)

\divisor

\subsubsection{FFT}
Faz multiplica\c{c}\~{a}o de polin\^{o}mios de grau $n$ em $O(n*log(n))$.\\
Para o algor\'{i}tmo funcionar, $n=2^k$. Se um polin\^{o}mio n\~{a}o tiver grau $2^k$, adicionar coeficientes nulos at\'{e} atingir a pr\'{o}xima pot\^{e}ncia de dois.\\
Lembrar que na multiplica\c{c}\~{a}o o polin\^{o}mio resultante ter\'{a} grau $2*n$, portanto adicionar zeros na frente dos polin\^{o}mios a serem multiplicados, deixando-os com grau $2^{k+1}$.
\Cpp{\detokenize{matematica/calculo/fft}}

% http://www.codechef.com/problems/FARASA
% mais info: http://habrahabr.ru/post/113642/
% mais recursos: http://www.ic.unicamp.br/~maratona/wiki/index.php?n=Numericos.FFT
\divisor

\subsubsection{Interpola\c{c}\~{a}o polinomial - Lagrange}
\Cpp{\detokenize{matematica/calculo/lagrange}}

% % % % % % % % % % % % %
% % ALGEBRA LINEAR
% % % % % % % % % % % % %

\subsection{Álgebra Linear}

\subsubsection{Recorrências lineares por matriz}
Em uma recorrência linear, pode-se encontrar o n-ésimo elemento em $O(\log{n})$ usando exponenciação de matrizes. Por exemplo, na sequência de Fibonacci temos:
\\ $f(n) = f(n)$
\\ $f(n+1) = f(n)+f(n-1)$
\\Na forma matricial, temos:
\\
$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right)
 = 
\left( \begin{array}{c}
f(n) + f(n-1) \\
f(n) \end{array} \right)
 = T \times
\left( \begin{array}{c}
f(n) \\
f(n-1) \end{array} \right)$
\\ Onde T é a matriz de transformação da recorrência e pode-se notar que:
$T=\left( \begin{array}{cc}
1 & 1 \\
1 & 0 \end{array} \right)$
\\ Seguindo a recorrência e lembrando que $f(0) = f(1) = 1$, tem-se que:
\\$\left( \begin{array}{c}
f(n+1) \\
f(n) \end{array} \right) = T^n \times
\left( \begin{array}{c}
1 \\
1 \end{array} \right)$
\\ No caso geral, se a matriz T for suficientemente pequena, pode-se calcular o n-ésimo item da recorrência ao se calcular $T^n$. A implementação em $O(\log{n})$ é obtida usando exponentiation by squaring, caso T seja suficientemente pequeno (multiplica\c{c}\~{a}o de matrizes: $O(n^3)$).
% Para treinar/testar: http://www.urionlinejudge.com.br/judge/problems/view/1422
% Mais detalhes: http://fusharblog.com/solving-linear-recurrence-for-programming-contest/

\divisor
\subsubsection{Gaussian Elimination}
Para resolu\c{c}\~{a}o de sistemas de equa\c{c}\~{o}es lineares. Para um sistema $A*x = B$, a matriz de input do algor\'{i}tmo \'{e} a matriz $A$ concatenada com $B$.
N\~{a}o funciona com matrizes singulares.
\Cpp{\detokenize{matematica/algebra_linear/gaussian_elimination}}
\divisor
