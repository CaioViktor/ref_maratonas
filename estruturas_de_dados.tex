\section{Estruturas de Dados}

\subsection{Segment Tree}
\Cpp{\detokenize{estruturas_de_dados/segment_tree}}
\divisor

\subsection{Sparse Table}
\subsubsection{Algor\'{i}tmo b\'{a}sico}
\Cpp{\detokenize{estruturas_de_dados/sparse_table}}
\divisor

\subsection{RMQ em \'{a}rvore}
Caso tenha um n\'{o} $u$ que contenha outro n\'{o} $v$ no caminho entre $u$ e a ra\'{i}z, o algor\'{i}tmo retorna a menor aresta entre $u$ e $v$.
\Cpp{\detokenize{estruturas_de_dados/sparse_table_rmq_tree}}
% Regional brasileira 2013: http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=4384
\divisor

\subsection{Union-Find Disjoint Sets}
\Cpp{\detokenize{estruturas_de_dados/union_find}}
\divisor

\subsection{Bitmasks}
\subsubsection{Operações Básicas}
\begin{tabular}{l | l}
		Ligar o i-ésimo bit: 		&   \texttt{S |= (1 << i)} 			\\
		Desligar o i-ésimo bit: 	&	\texttt{S \&= \textasciitilde(1 << i)} 		\\
		Toggle no i-ésimo bit:		&   \texttt{S \textasciicircum= (1 << i)} 			\\
		Checar se i-ésimo bit é 0  	&	\texttt{(S \& (1 << i)) == 0} 	\\
		Checar se o i-ésimo bit é 1 &	\texttt{(S \& (1 << i)) != 0} 	\\
		Pegar o primeiro bit ligado	& 	\texttt{T = (S \& (-S))} 		\\
		Ligar os primeiros n bits	& 	\texttt{S = (1 << n) - 1} 		\\
		Desligar todos os bits		& 	\texttt{S = 0} 
\end{tabular}

\subsubsection{Combinações}
Gera as bitmasks de todas combinações de K elementos em N:
\Cpp{\detokenize{estruturas_de_dados/combinacoes_bitmask}}

\subsubsection{Contar quantidade de bits ligados}
\Cpp{\detokenize{estruturas_de_dados/bitmask_count}}

\subsubsection{XOR de sequ\^{e}ncia}
Para calcular o XOR de uma sequ\^{e}ncia de 1 a N.
\Cpp{\detokenize{estruturas_de_dados/seq_xors}}
% Explica\c{c}\~{a}o: http://stackoverflow.com/questions/3932346/direct-formula-for-summing-xor
\divisor

\subsubsection{Pr\'{o}ximo com x bits}
Retorna o pr\'{o}ximo maior ou menor inteiro com a mesma quantidade de bits que o input.
\Cpp{\detokenize{estruturas_de_dados/nxt_cnt}}

\subsection{DP Optimization}
\subsubsection{Convex hull trick}
Nesse caso, as linhas a serem adicionadas est\~{a}o ordenadas por slope (M). Insert e query em $O(1)$.
\Cpp{\detokenize{estruturas_de_dados/convex_hull_trick}}

% ARRUMAR VERSAO DINAMICA - SO FUNCIONA COM C++11
% Vers\~{a}o din\^{a}mica. Insert e query em $O(log n)$.
% \Cpp{\detokenize{estruturas_de_dados/convex_hull_trick_dyn}}
\divisor
